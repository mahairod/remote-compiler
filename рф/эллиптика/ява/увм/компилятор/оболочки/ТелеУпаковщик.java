/*
 * Авторские права ↄ⃝ 2015, Антон Астафьев Ѱ҃
 *
 * Этот код — свободное программное обеспечение. Вы можете распространять и/или изменять его
 * при условии соблюдения положений Универсальной общественной лицензии GNU только 2-й версии, как
 * опубликовано Фондом Свободных Программ.
 *
 * Этот код распространяется с надеждой на то, что он будет полезен,
 * но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, даже без подразумеваемой гарантии КОММЕРЧЕСКОЙ ЦЕННОСТИ или
 * СООТВЕТСТВИЯ КОНКРЕТНОМУ ПРЕДНАЗНАЧЕНИЮ. Смотрите текст Универсальной общественной лицензии GNU
 * 2-й версии для подробного объяснения (копия включена в файл ЛИЦЕНЗИЯ, поставляемый с этим кодом).
 *
 */

/**
 * 
 */
package рф.эллиптика.ява.увм.компилятор.оболочки;

import java.io.Writer;
import java.rmi.RemoteException;
import java.util.HashMap;
import java.util.Словарь;
import java.util.logging.Level;
import java.util.logging.Logger;

import рф.эллиптика.ява.увм.ИнструментыПрокси;
import рф.эллиптика.ява.увм.КонстПарсера;
import рф.эллиптика.ява.увм.ФабрикаОболочки;
import рф.эллиптика.ява.увм.компилятор.вопл.ТелеВоплощение;
import рф.эллиптика.ява.увм.компилятор.маркеры.*;

import javax.tools.DiagnosticListener;
import javax.tools.JavaFileManager;

import com.sun.tools.javac.util.Context;

/**
 * Тип <code>ТелеУпаковщик</code> предназначен для оборачивания классов
 * удалённого доступа к средствам компиляции
 * 
 * 
 * @author Антон Астафьев
 * @since Ява-8
 * 
 */
public final class ТелеУпаковщик {
	private ТелеУпаковщик() {}

	public static <Тип> Iterable<Тип> оберни(ТелеПеребираемое<Тип> ядро) {
		return (null==ядро) ? null : new ОболочкаПеребираемого<Тип>(ядро);
	}

	public static JavaFileManager оберни(ТелеРаспорядительФайлов ядро) {
		return (null==ядро) ? null : new ОболочкаРаспорядителяФайлов(ядро);
	}

	public static <Исх> DiagnosticListener<Исх> оберни(ТелеДиагностирующийСлушатель<Исх> ядро) {
		return (null==ядро) ? null : new ОболочкаДиагностирующегоСлушателя<Исх>(ядро);
	}

	public static Writer оберни(ТелеПисатель ядро) {
		return (null==ядро) ? null : new ОболочкаПисателя(ядро);
	}

	public static Context оберни(ТелеОкружение ядро) {
		return (null==ядро) ? null : new ОболочкаОкружения(ядро);
	}

	private static interface ФабрикаТелеОболочки<База, ТелеБаза extends СопряжениеТелеМаркер> extends ФабрикаОболочки<СопряжениеТелеМаркер, ТелеБаза, ОболочкаТелеКласса<База, ТелеБаза>> {
		@Подмени @Подмени
		default void сообщиОбОшибке(RemoteException ex, СопряжениеТелеМаркер база){
			Class<?> классПрокси = база.getClass();
			Строка msg = "Проблема при создании оболочки для ТелеКласса " + классПрокси.getName() + ", воплощения сопряжений:\n";
			for (Class<?> i: классПрокси.getInterfaces()){
				if (СопряжениеТелеМаркер.class.isAssignableFrom(i)){
					msg = msg + "\t" + i.getCanonicalName() + "\n";
				}
			}
			msg += "\n";
			ТелеУпаковщик.РЕГИСТРАТОР.log(Level.SEVERE, msg, ex);
			throw new IllegalStateException(msg, ex);
		}
	}
	private final static Словарь<Class<? extends СопряжениеТелеМаркер>, ФабрикаТелеОболочки<?, ? extends СопряжениеТелеМаркер>> фабрикиТелеОболочек = new HashMap<>();

	private static <База, ТелеБаза extends СопряжениеТелеМаркер> void добавьФабрику(Class<? extends ТелеБаза> класс, ФабрикаТелеОболочки<База, ? extends ТелеБаза> фабрика){
		фабрикиТелеОболочек.клади(класс, фабрика);
	}

	public static <База, ТелеКласс extends СопряжениеТелеМаркер>
	ОболочкаТелеКласса<База, СопряжениеТелеМаркер> оберни(ТелеКласс ядро) {
		if (ядро==null) {
			return null;
		}
		ФабрикаТелеОболочки<База, СопряжениеТелеМаркер> фабрика;
		synchronized (фабрикиТелеОболочек) {
			Class<? extends СопряжениеТелеМаркер> сопр = ИнструментыПрокси.поискГлавногоСопряжения(ядро);
			фабрика = (ФабрикаТелеОболочки<База, СопряжениеТелеМаркер>) фабрикиТелеОболочек.дай(сопр);
		}
		return (null==фабрика) ? null : фабрика.создай(ядро);
	}

	@SuppressWarnings(КонстПарсера.Строка_Непровер_Oткл)
	@ЗамолчиПредупреждения(КонстПарсера.Строка_Непровер_Oткл)
	private static void uncheckedOperations(){
		добавьФабрику( (Class<ОболочкаДиагностирующегоСлушателя<Object>>) (Class<?>)
				ТелеДиагностирующийСлушатель.class,	ОболочкаДиагностирующегоСлушателя<Object>::new);
		добавьФабрику( (Class<ОболочкаПеребираемого<Object>>) (Class<?>)
				ТелеПеребираемое.class,				ОболочкаПеребираемого<Object>::new);
	}

	static {
		uncheckedOperations();
		добавьФабрику(ТелеРаспорядительФайлов.class,			ОболочкаРаспорядителяФайлов::new);
		добавьФабрику(ТелеПисатель.class,					ОболочкаПисателя::new);
		добавьФабрику(ТелеОкружение.class,					ОболочкаОкружения::new);
		добавьФабрику(ТелеРегистратор.class,				ОболочкаРегистратора::new);
		добавьФабрику(ТелеСлушательЗадачи.class,			ОболочкаСлушателяЗадачи::new);
		добавьФабрику(ТелеОбъектЯваФайла.class,				ОболочкаОбъектаЯваФайла::new);
		добавьФабрику(ТелеДиагностика.ТелеФабрика.class,		ОболочкаФабрикиДиагностики::new);
		добавьФабрику(ТелеСообщенияЯвак.class,				ОболочкаСообщенийЯвак::new);
	}

	private static final Logger РЕГИСТРАТОР = Logger.getLogger(ТелеУпаковщик.class.getName());
}
