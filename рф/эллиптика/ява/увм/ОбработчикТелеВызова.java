/*
 * Авторские права ↄ⃝ 2015, Антон Астафьев Ѱ҃
 *
 * Этот код — свободное программное обеспечение. Вы можете распространять и/или изменять его
 * при условии соблюдения положений Универсальной общественной лицензии GNU только 2-й версии, как
 * опубликовано Фондом Свободных Программ.
 *
 * Этот код распространяется с надеждой на то, что он будет полезен,
 * но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, даже без подразумеваемой гарантии КОММЕРЧЕСКОЙ ЦЕННОСТИ или
 * СООТВЕТСТВИЯ КОНКРЕТНОМУ ПРЕДНАЗНАЧЕНИЮ. Смотрите текст Универсальной общественной лицензии GNU
 * 2-й версии для подробного объяснения (копия включена в файл ЛИЦЕНЗИЯ, поставляемый с этим кодом).
 *
 */

package рф.эллиптика.ява.увм;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.rmi.server.RemoteObjectInvocationHandler;

import рф.эллиптика.ява.увм.компилятор.вопл.ТелеВоплощение;
import рф.эллиптика.ява.увм.компилятор.вопл.ТелеЭкспорт;
import рф.эллиптика.ява.увм.компилятор.контейнер.Контейнер;
import рф.эллиптика.ява.увм.компилятор.маркеры.СопряжениеТелеМаркер;
import рф.эллиптика.ява.увм.компилятор.оболочки.ОболочкаТелеКласса;
import рф.эллиптика.ява.увм.компилятор.оболочки.ТелеУпаковщик;

/**
 *
 * @author Антон Астафьев
 */
public abstract class ОбработчикТелеВызова<Рез, Откл extends Throwable, ОбщОткл extends Throwable> extends ОбработчикТелеВызоваСпец {
	protected final ШлюзовойКласс оболочка;
	protected final ДелегатОбщий<Рез, Откл, ОбщОткл> делегат;
	protected final ТелеЭкспорт телеЭкспорт;
	protected Рез рез;

	protected ОбработчикТелеВызова(ДелегатОбщий<Рез, Откл, ОбщОткл> делегат, ШлюзовойКласс оболочка) {
		this.делегат = делегат;
		this.оболочка = оболочка;
		this.телеЭкспорт = ТелеЭкспорт.экземпляр();
	}

	@ЗамолчиПредупреждения(КонстПарсера.Строка_Непровер_Oткл)
	protected abstract Рез результат();

	protected abstract ОбработчикТелеВызова<Рез,Откл,ОбщОткл>
	вызов(Object... параметры) throws Откл;

	protected Object обработкаТелеОбъекта(СопряжениеТелеМаркер телеОбъект, boolean обернуть){
		if (телеОбъект instanceof ОболочкаТелеКласса){
			ОболочкаТелеКласса<Object, СопряжениеТелеМаркер> обёрнутый = (ОболочкаТелеКласса<Object, СопряжениеТелеМаркер>) телеОбъект;
			СопряжениеТелеМаркер резТелеОбъект;
			if (обернуть){
				резТелеОбъект = оболочка.внутреннееПредставление(обёрнутый);
			}else{
				резТелеОбъект = оболочка.внешнееПредставление(обёрнутый);
			}
			return (Рез) резТелеОбъект;
		} else if (телеОбъект instanceof Proxy) {
			InvocationHandler ih = Proxy.getInvocationHandler(телеОбъект);
			if (ih instanceof RemoteObjectInvocationHandler){
				RemoteObjectInvocationHandler roih = (RemoteObjectInvocationHandler) ih;
				Object оригинал = ТелеВоплощение.поищиЯдроОригинала(roih.getRef());
				if (оригинал!=null){
					return оригинал;
				}
			}
			if (обернуть){
				ОболочкаТелеКласса<Рез, СопряжениеТелеМаркер> оболочка = ТелеУпаковщик.оберни(телеОбъект);
				return null!=оболочка ? (Рез)оболочка : телеОбъект;
			} else {
				return телеОбъект;
			}
		} else {
			return телеОбъект;
		}
	}
	
	protected Object дополнРазвёртка(Object парам) {
		return null;
	}

	@Подмени
	protected Object замениПараметр(Object п, boolean обернуть) {
		if (п == null){
			return null;
		}
		if (п instanceof СопряжениеТелеМаркер){
			return обработкаТелеОбъекта( (СопряжениеТелеМаркер)п, обернуть);
		}
		{
			Object новПар = дополнРазвёртка(п);
			if (новПар!=null){
				return новПар;
			}
		}
		// обработка Коллекций
		if (п.getClass().isArray()){
			Object[] исхМассив = (Object[]) п;
			if (исхМассив.length==0){
				return исхМассив;
			}
			Object[] промежМассив = new Object[исхМассив.length];
			for (int i=0;i<исхМассив.length; i++){
				промежМассив[i] = замениПараметр( исхМассив[i], обернуть );
			}
			Class<?> типКомпонента = промежМассив[0].getClass();
			if (промежМассив[0] instanceof СопряжениеТелеМаркер){
				Class<?>[] сопряжения = типКомпонента.getInterfaces();
				if (промежМассив[0] instanceof ОболочкаТелеКласса){
					Class<?> найденныйТип = null;
					for (Class<?> сопряжение : сопряжения ){
						if ( !СопряжениеТелеМаркер.class.isAssignableFrom(сопряжение) ){
							найденныйТип = сопряжение;
							break;
						}
					}
					типКомпонента = найденныйТип!=null? найденныйТип : типКомпонента.getSuperclass(); 
				} else {
					for (Class<?> сопряжение : сопряжения ){
						if (СопряжениеТелеМаркер.class.isAssignableFrom(сопряжение)){
							типКомпонента = сопряжение;
							break;
						}
					}
				}
			}
			Object[] резМассив = (Object[]) Array.newInstance(типКомпонента, исхМассив.length);
			for (int i=0;i<исхМассив.length; i++){
				резМассив[i] = промежМассив[i];
			}
			return резМассив;
		}
		if (п instanceof Iterable){
			return обработкаКоллекций(п, обернуть);
		}
		if (п instanceof Контейнер){
			return поСсылке((Контейнер)п);
		} else if (ссылочныйТип(п)){
			return ссылка(п);
		}
		if (! (п instanceof Serializable) ){
			Serializable repl = оболочка.замена(п);
			if (repl!=null){
				return repl;
			} else {
				return телеЭкспорт.заменаНаПрокси(п);
			}
		}
		return п;
	}

	protected Object ссылка(Object исх) {
		char[] тип = исх.getClass().getCanonicalName().toCharArray();
		Контейнер контейнер =  new Контейнер(тип, исх.hashCode());
		сохраниСсылку(контейнер, исх);
		return контейнер;
	}

}
